---
title: "Health Predictions"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
runtime: shiny
css: styles.css
---

```{r setup, include=FALSE}

### To change to new data set, replace penguins everywhere :) 
library(flexdashboard)
library(palmerpenguins)
library(caret) 
library(DT)
library(ggplot2)
library(sortable)
library(modelr)

# Questions/todos:
# 1. Currently getting "Warning in predict.lm(model1(), test_dataset) :prediction from a rank-deficient fit may be misleading"

# Todos:
# 1. Switch to binary classifier?
# 2. Make it easier to select features. 
# 3. Make relationship with features stronger. 
# 4. Make it possible to gather race data etc.

train_dataset = read.csv("train_data.csv", header = TRUE ,sep = ",")
test_dataset = read.csv('test_data.csv', header=TRUE, sep=',')

exists("train_dataset")
exists("test_dataset")

BASE_COST_PER_ROW = 25
DEMOGRAPHICS_COST_PER_ROW = 20
ORIGINAL_BUDGET = 1000000
ORIGINAL_ROWS = 100
budget <- reactiveValues(v = ORIGINAL_BUDGET - ORIGINAL_ROWS * BASE_COST_PER_ROW)
n_rows_purchased <- reactiveValues(v = ORIGINAL_ROWS)
cost_per_row <- reactiveValues(v = BASE_COST_PER_ROW)
demographics_purchased <- reactiveValues(age = 0, sex = 0, race = 0)
status_update_message <- reactiveValues(message='Do you wish to purchase additional training data?')

```


Build model
=====================================  
  


Column {data-width=300}
----------------------------------------------------------------------- 

```{r}

# data collection buttons
actionButton("buy_thousand_more_rows", "Collect 1,000 more rows of data")
actionButton("add_race_data", "Collect data on patient race")
actionButton("add_sex_data", "Collect data on patient sex")
actionButton("add_age_data", "Collect data on patient age")

# define actions
observeEvent(input$buy_thousand_more_rows, {
  if((ORIGINAL_BUDGET - (n_rows_purchased$v + 1000) *  cost_per_row$v) < 0){
    status_update_message$message = 'You do not have enough budget to purchase additional rows of training data.'
    
  }else{
    n_rows_purchased$v = n_rows_purchased$v + 1000;
    budget$v = ORIGINAL_BUDGET - n_rows_purchased$v *  cost_per_row$v;
   status_update_message$message = '1,000 rows of training data purchased!'
  }
})


observeEvent(input$add_race_data, {
  potential_cost_per_row = (BASE_COST_PER_ROW + DEMOGRAPHICS_COST_PER_ROW * (max(demographics_purchased$race, 1) + 
                                                                       demographics_purchased$age + 
                                                                       demographics_purchased$sex))
    if((ORIGINAL_BUDGET - n_rows_purchased$v *  potential_cost_per_row) < 0){
      status_update_message$message = 'You do not have enough budget to purchase data on race.'
    }else{
      if(demographics_purchased$race == 0){
        status_update_message$message = 'Data on race purchased!'
      }
      else{
        status_update_message$message = 'Data on race was already purchased.'
      }
      demographics_purchased$race = 1;
      cost_per_row$v = potential_cost_per_row
      budget$v = ORIGINAL_BUDGET - n_rows_purchased$v *  cost_per_row$v;
     
    }
  })

observeEvent(input$add_sex_data, {
  potential_cost_per_row = (BASE_COST_PER_ROW + DEMOGRAPHICS_COST_PER_ROW * (max(demographics_purchased$sex, 1) + 
                                                                       demographics_purchased$age + 
                                                                       demographics_purchased$race))
    if((ORIGINAL_BUDGET - n_rows_purchased$v *  potential_cost_per_row) < 0){
     status_update_message$message = 'You do not have enough budget to purchase data on sex.'
    }else{
      if(demographics_purchased$sex == 0){
        status_update_message$message = 'Data on sex purchased!'
      }
      else{
        status_update_message$message = 'Data on sex was already purchased.'
      }
      demographics_purchased$sex = 1;
      cost_per_row$v = potential_cost_per_row
      budget$v = ORIGINAL_BUDGET - n_rows_purchased$v *  cost_per_row$v;
      
    }
  })
observeEvent(input$add_age_data, {
  potential_cost_per_row = (BASE_COST_PER_ROW + DEMOGRAPHICS_COST_PER_ROW * (max(demographics_purchased$age, 1) + 
                                                                       demographics_purchased$sex + 
                                                                       demographics_purchased$race))
    if((ORIGINAL_BUDGET - n_rows_purchased$v *  potential_cost_per_row) < 0){
       status_update_message$message = 'You do not have enough budget to purchase data on age.'
    }else{
      if(demographics_purchased$age == 0){
        status_update_message$message = 'Data on age purchased!'
      }
      else{
        status_update_message$message = 'Data on age was already purchased.'
      }
      demographics_purchased$age = 1;
      cost_per_row$v = potential_cost_per_row
      budget$v = ORIGINAL_BUDGET - n_rows_purchased$v *  cost_per_row$v;
      
    }
  })

renderText(status_update_message$message)

renderText({
 paste('Total remaining budget: $', as.integer(budget$v), sep='')
})

renderText({
 paste('Total rows in dataset:', n_rows_purchased$v)
})

renderText({
 paste('Cost per row of data: $', cost_per_row$v, sep='')
})

  bucket_list(
        header = "Drag variables to build your model",
        group_name = "bucket_list_group",
        orientation = "vertical",
        add_rank_list(
          text = "Not used",
          # change the variable names
          labels = names(train_dataset),
          input_id = "out_model"
        ),
        add_rank_list(
          text = "Used",
          labels = NULL,
          input_id = "in_model"
        )
      )
```



Column {data-width=400, data-height=300}
-----------------------------------------------------------------------

### Predictions vs truth

```{r}


usable_train_dataset <- reactive({
  train_dataset[1:n_rows_purchased$v,]
})


model1 <- reactive({
  if(length(input$in_model) > 0){
    #change this to new data
    lm1 = lm(as.formula(paste0("Chronic_illnesses ~ ",paste0(input$in_model,collapse="+"))),
         data=usable_train_dataset())
  }else{
    # change to new data
    lm1 = lm(Chronic_illnesses ~ 1,data=usable_train_dataset())
  }
  
})

renderPlot({ 
  
test_dataset %>%
    add_predictions(model1()) %>%
    ggplot(aes_string(x="Chronic_illnesses",y="pred")) +
    geom_point()

})
```

### RMSE

```{r}

renderText({
  sqrt(
    sum(
      (predict(model1(), test_dataset) - test_dataset$Chronic_illnesses)^2
      )
    )
})
```






Data Description/Dictionary
===================================== 
Predictor: Chronic_illnesses

Factors:

* Normal_mean_creatinine- An indicator of kidney function
* Normal_mean_hematocrit - Red blood cell count
* Normal_mean_GHbA1c - Plasma glucose; used to diagnose diabetes
* Normal_mean_LDL - Low denisty lipids; used to evaluate cholestorol 
* Normal_mean_BNP - Brain natriuretic peptide; indicates risk of heart failure
* Normal_mean_sodiumm - could indicate heart failure or kidney disease
* Normal_mean_triglycerides - could indicate risk of diabetes or heart disease


Health Data
===================================== 


```{r}
datatable(test_dataset,fillContainer = FALSE) 
```


Explore Health Data
===================================== 

Column {.sidebar}
-----------------------------------------------------------------------



```{r}
   # changed to new data
radioButtons("plottype", h4("Plot type"),
                        choices = c("scatterplot","boxplot"),selected="scatterplot")

selectInput("xvariable", h4("Pick x-variable"),
                        choices = colnames(test_dataset), selected="trig_mean_normal_tm1")

selectInput("yvariable", h4("Pick y-variable"),
                        choices = colnames(test_dataset), selected="Chronic_illnesses")

```

Column 
-----------------------------------------------------------------------

### Health plot

```{r}

# change to new data
renderPlot(
  if(input$plottype=="scatterplot"){
    test_dataset %>% 
      ggplot(aes_string(x=input$xvariable,y=input$yvariable)) + geom_point()
  }else{
    test_dataset %>% 
      ggplot(aes_string(x=input$xvariable,y=input$yvariable)) + geom_boxplot()
  }
)
```



