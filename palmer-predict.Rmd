---
title: "Health Predictions"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
runtime: shiny
css: styles.css
---

```{r setup, include=FALSE}

### To change to new data set, replace penguins everywhere :) 
library(flexdashboard)
library(palmerpenguins)
library(caret) 
library(DT)
library(ggplot2)
library(sortable)
library(modelr)
library(dplyr)

# Questions/todos:
# 1. Currently getting "Warning in predict.lm(model1(), test_dataset) :prediction from a rank-deficient fit may be misleading"

# Todos:
# 1. Switch to binary classifier?
# 2. Make it easier to select features. 
# 3. Make relationship with features stronger. 
# 4. Make it possible to gather race data etc.

train_dataset = read.csv("train_data.csv", header = TRUE ,sep = ",")
test_dataset = read.csv('test_data.csv', header=TRUE, sep=',')
all_columns = names(train_dataset)
originally_available_columns = all_columns[(all_columns != 'Chronic_illnesses') & 
                                           (all_columns != 'Race') & 
                                           (all_columns != 'Age') & 
                                           (all_columns != 'Sex')]
                                                      

exists("train_dataset")
exists("test_dataset")
exists("originally_available_columns")
exists("all_columns")

BASE_COST_PER_ROW = 25
DEMOGRAPHICS_COST_PER_ROW = 20
ORIGINAL_BUDGET = 1000000
ORIGINAL_ROWS = 100
budget <- reactiveValues(v = ORIGINAL_BUDGET - ORIGINAL_ROWS * BASE_COST_PER_ROW)
purchased_idxs <- reactiveValues(v = c(!logical(ORIGINAL_ROWS), logical(nrow(train_dataset) - ORIGINAL_ROWS)))
cost_per_row <- reactiveValues(v = BASE_COST_PER_ROW)
demographics_purchased <- reactiveValues(age = 0, sex = 0, race = 0)
status_update_message <- reactiveValues(message='Do you wish to purchase additional training data?')
reactive_available_demographics <- reactiveValues(v=c())
reactive_available_columns <- reactiveValues(v = originally_available_columns)

```


Build model
=====================================  
  


Column {data-width=300}
----------------------------------------------------------------------- 

```{r}

# data collection buttons

# define actions
observeEvent(input$buy_thousand_more_rows, {
  
  n_rows_purchased = sum(purchased_idxs$v)
  if((ORIGINAL_BUDGET - (n_rows_purchased + 1000) *  cost_per_row$v) < 0){
    status_update_message$message = 'You do not have enough budget to purchase additional rows of training data.'
  }else{
    rows_available_for_purchase = which(purchased_idxs$v == FALSE) # default 
    message = '1,000 rows of training data purchased!'
    if(startsWith(input$upsample_data, 'Gather data from')){
      split_string = strsplit(input$upsample_data, split=' = ')
      val = tolower(split_string[[1]][2])
      remaining_tokens = strsplit(split_string[[1]][1], split = ' ')[[1]]
      key = remaining_tokens[length(remaining_tokens)]
      candidate_idxs = (purchased_idxs$v == FALSE) & (tolower(train_dataset[,key]) == val)
      if(sum(candidate_idxs) >= 1000){
        rows_available_for_purchase = which(candidate_idxs)
        message = paste0('Purchased a thousand rows of training data with ', key, ' = ', val, '!') 
      }else{
        message = paste0('Unable to purchase a thousand rows of training data with ', key, ' = ', val, '; not enough data. Sampled from entire dataset.')
      }
    }
    rows_purchased = rows_available_for_purchase[1:1000]
    purchased_idxs$v[rows_purchased] = TRUE
    n_rows_purchased = sum(purchased_idxs$v)
    budget$v = ORIGINAL_BUDGET - n_rows_purchased *  cost_per_row$v;
   status_update_message$message = message
  }
})

get_upsampling_choices <- function(available_demographics) {
  upsampling_choices = c('No, sample from full population.')
  for (dem in available_demographics) {
    if(dem == 'Age'){upsampling_choices = c(upsampling_choices, paste('Gather data from people with Age =', as.list(unique(train_dataset$Age))))}
    else if(dem == 'Sex'){upsampling_choices = c(upsampling_choices, paste('Gather data from people with Sex =', as.list(unique(train_dataset$Sex))))}
    else if(dem == 'Race'){upsampling_choices = c(upsampling_choices, paste('Gather data from people with Race =', as.list(unique(train_dataset$Race))))}
    else{stopifnot(FALSE)}
  } 
  upsampling_choices
}

radioButtons(
  'upsample_data',
  "Do you want to collect data on subpopulations?",
  choices = c('No, sample from full population.')
)


actionButton("buy_thousand_more_rows", "Collect 1,000 more rows of data")


actionButton("add_race_data", "Collect data on patient race")
actionButton("add_sex_data", "Collect data on patient sex")
actionButton("add_age_data", "Collect data on patient age")
observeEvent(input$add_race_data, {
  potential_cost_per_row = (BASE_COST_PER_ROW + DEMOGRAPHICS_COST_PER_ROW * (max(demographics_purchased$race, 1) + 
                                                                       demographics_purchased$age + 
                                                                       demographics_purchased$sex))
    if((ORIGINAL_BUDGET - sum(purchased_idxs$v) *  potential_cost_per_row) < 0){
      status_update_message$message = 'You do not have enough budget to purchase data on race.'
    }else{
      if(demographics_purchased$race == 0){
        status_update_message$message = 'Data on race purchased!'
        reactive_available_demographics$v = c(reactive_available_demographics$v, 'Race')
        reactive_available_columns$v = c(originally_available_columns, reactive_available_demographics$v)
        #updateCheckboxGroupInput(inputId="variables_to_use_in_model", choices=reactive_available_columns$v)
        updateRadioButtons(inputId='stratify_performance', choices=c('Full population', reactive_available_demographics$v))
        updateRadioButtons(inputId='fit_separate_models', choices=c('Fit one model on full population', reactive_available_demographics$v))
        updateRadioButtons(inputId='upsample_data', choices=get_upsampling_choices(reactive_available_demographics$v))
      }
      else{
        status_update_message$message = 'Data on race was already purchased.'
      }
      demographics_purchased$race = 1;
      cost_per_row$v = potential_cost_per_row
      budget$v = ORIGINAL_BUDGET - sum(purchased_idxs$v) *  cost_per_row$v;
     
    }
  })

observeEvent(input$add_sex_data, {
  potential_cost_per_row = (BASE_COST_PER_ROW + DEMOGRAPHICS_COST_PER_ROW * (max(demographics_purchased$sex, 1) + 
                                                                       demographics_purchased$age + 
                                                                       demographics_purchased$race))
    if((ORIGINAL_BUDGET - sum(purchased_idxs$v) *  potential_cost_per_row) < 0){
     status_update_message$message = 'You do not have enough budget to purchase data on sex.'
    }else{
      if(demographics_purchased$sex == 0){
        status_update_message$message = 'Data on sex purchased!'
        reactive_available_demographics$v = c(reactive_available_demographics$v, 'Sex')
        reactive_available_columns$v = c(originally_available_columns, reactive_available_demographics$v)
        #updateCheckboxGroupInput(inputId="variables_to_use_in_model", choices=reactive_available_columns$v)
        updateRadioButtons(inputId='stratify_performance', choices=c('Full population', reactive_available_demographics$v))
        updateRadioButtons(inputId='fit_separate_models', choices=c('Fit one model on full population', reactive_available_demographics$v))
        updateRadioButtons(inputId='upsample_data', choices=get_upsampling_choices(reactive_available_demographics$v))
      }
      else{
        status_update_message$message = 'Data on sex was already purchased.'
      }
      demographics_purchased$sex = 1;
      cost_per_row$v = potential_cost_per_row
      budget$v = ORIGINAL_BUDGET - sum(purchased_idxs$v) *  cost_per_row$v;
      
    }
  })

observeEvent(input$add_age_data, {
  potential_cost_per_row = (BASE_COST_PER_ROW + DEMOGRAPHICS_COST_PER_ROW * (max(demographics_purchased$age, 1) + 
                                                                       demographics_purchased$sex + 
                                                                       demographics_purchased$race))
    if((ORIGINAL_BUDGET - sum(purchased_idxs$v) *  potential_cost_per_row) < 0){
       status_update_message$message = 'You do not have enough budget to purchase data on age.'
    }else{
      if(demographics_purchased$age == 0){
        status_update_message$message = 'Data on age purchased!'
        reactive_available_demographics$v = c(reactive_available_demographics$v, 'Age')
        reactive_available_columns$v = c(originally_available_columns, reactive_available_demographics$v)
        #updateCheckboxGroupInput(inputId="variables_to_use_in_model", choices=reactive_available_columns$v)
        updateRadioButtons(inputId='stratify_performance', choices=c('Full population', reactive_available_demographics$v))
        updateRadioButtons(inputId='fit_separate_models', choices=c('Fit one model on full population', reactive_available_demographics$v))
        updateRadioButtons(inputId='upsample_data', choices=get_upsampling_choices(reactive_available_demographics$v))
      }
      else{
        status_update_message$message = 'Data on age was already purchased.'
      }
      demographics_purchased$age = 1;
      cost_per_row$v = potential_cost_per_row
      budget$v = ORIGINAL_BUDGET - sum(purchased_idxs$v) *  cost_per_row$v;
      
    }
  })

renderText(status_update_message$message)

renderText({
 paste('Total remaining budget: $', as.integer(budget$v), sep='')
})

renderText({
 paste('Total rows in dataset:', sum(purchased_idxs$v))
})

renderText({
 paste('Cost per row of data: $', cost_per_row$v, sep='')
})

checkboxGroupInput(
  "variables_to_use_in_model", 
  "Which variables do you want to include in your model?",
  originally_available_columns, 
  inline=TRUE)

radioButtons(
  'fit_separate_models',
  "Do you want to fit separate models by age, race, or sex?",
  choices = c('Fit one model on full population')
)

radioButtons(
  'stratify_performance',
  "How do you want to break down the results?",
  choices = c('Full population')
)

```



Column {data-width=400, data-height=300}
-----------------------------------------------------------------------

### Predictions vs truth

```{r}

usable_train_dataset <- reactive({
  train_dataset[purchased_idxs$v,]
})


model1 <- reactive({
  if(length(input$variables_to_use_in_model) > 0){
    #change this to new data
    rhs_formula = paste0(input$variables_to_use_in_model, collapse="+")
    if(input$fit_separate_models != 'Fit one model on full population'){
      rhs_formula = paste0(input$fit_separate_models, '*(', rhs_formula, ')')
    }
    lm1 = lm(as.formula(paste0("Chronic_illnesses ~ ", rhs_formula)), data=usable_train_dataset())
  }else{
    if(input$fit_separate_models != 'Fit one model on full population'){
      lm1 = lm(paste0('Chronic_illnesses ~ ', input$fit_separate_models), data=usable_train_dataset())
    }else{lm1 = lm(Chronic_illnesses ~ 1,data=usable_train_dataset())}
    
  }
  
})

renderPlot({ 
  
test_dataset %>%
    add_predictions(model1()) %>%
    ggplot(aes_string(x="Chronic_illnesses",y="pred")) +
    geom_point()

})
```

### RMSE

```{r}

results_table = reactive({
  test_dataset$preds = predict(model1(), test_dataset)
  test_dataset$err = test_dataset$preds - test_dataset$Chronic_illnesses
  if(input$stratify_performance == 'Full population'){
    table = data.frame("Group"="Full population", 
                       "RMSE" = sqrt(mean((test_dataset$err)^2)), 
                       "n" = nrow(usable_train_dataset()))
    table['% of data'] = 100
  }else if(input$stratify_performance=='Age'){
    table = test_dataset %>% 
      group_by(Age) %>% 
      summarize(RMSE=sqrt(mean(err^2)))
    counts = usable_train_dataset() %>% group_by(Age) %>% summarise(n = n())
    counts['% of data'] = 100 * counts$n / nrow(usable_train_dataset())
    table = merge(table, counts, by='Age')
    
  }else if(input$stratify_performance=='Race'){
    table = test_dataset %>% 
      group_by(Race) %>% 
      summarize(RMSE=sqrt(mean(err^2)))
    counts = usable_train_dataset() %>% group_by(Race) %>% summarise(n = n())
    counts['% of data'] = 100 * counts$n / nrow(usable_train_dataset())
    table = merge(table, counts, by='Race')
  }
  else if(input$stratify_performance=='Sex'){
    table = test_dataset %>% 
      group_by(Sex) %>% 
      summarize(RMSE=sqrt(mean(err^2)))
    counts = usable_train_dataset() %>% group_by(Sex) %>% summarise(n = n())
    counts['% of data'] = 100 * counts$n / nrow(usable_train_dataset())
    table = merge(table, counts, by='Sex')
  }else{
    stopifnot(FALSE)
  }
  table
})

renderTable({results_table()}, digits=4)
```






Data Description/Dictionary
===================================== 
Thing to predict: Chronic_illnesses

Factors:

* Normal_mean_creatinine- An indicator of kidney function
* Normal_mean_hematocrit - Red blood cell count
* Normal_mean_GHbA1c - Plasma glucose; used to diagnose diabetes
* Normal_mean_LDL - Low denisty lipids; used to evaluate cholestorol 
* Normal_mean_BNP - Brain natriuretic peptide; indicates risk of heart failure
* Normal_mean_sodiumm - could indicate heart failure or kidney disease
* Normal_mean_triglycerides - could indicate risk of diabetes or heart disease


Health Data
===================================== 


```{r}
datatable(test_dataset,fillContainer = FALSE) 
```


Explore Health Data
===================================== 

Column {.sidebar}
-----------------------------------------------------------------------



```{r}
   # changed to new data
radioButtons("plottype", h4("Plot type"),
                        choices = c("scatterplot","boxplot"),selected="scatterplot")

selectInput("xvariable", h4("Pick x-variable"),
                        choices = colnames(test_dataset), selected="trig_mean_normal_tm1")

selectInput("yvariable", h4("Pick y-variable"),
                        choices = colnames(test_dataset), selected="Chronic_illnesses")

```

Column 
-----------------------------------------------------------------------

### Health plot

```{r}

# change to new data
renderPlot(
  if(input$plottype=="scatterplot"){
    test_dataset %>% 
      ggplot(aes_string(x=input$xvariable,y=input$yvariable)) + geom_point()
  }else{
    test_dataset %>% 
      ggplot(aes_string(x=input$xvariable,y=input$yvariable)) + geom_boxplot()
  }
)
```



